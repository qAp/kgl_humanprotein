# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_data.ipynb (unless otherwise specified).

__all__ = ['imgids_from_directory', 'imgids_testing', 'read_img', 'load_RGBY_image', 'CellSegmentator', 'get_cellmask']

# Cell
import os
from pathlib import Path
from itertools import groupby
from multiprocessing import Pool
from pycocotools import mask as mutils
from pycocotools import _mask as coco_mask
import numpy as np
import pandas as pd
import cv2, PIL
import zlib
import base64

# Cell
def imgids_from_directory(path):
    if isinstance(path, str):
        path = Path(path)

    imgids = set(n.stem.split('_')[0] for n in path.iterdir())
    return list(imgids)

# Cell
imgids_testing = [
    '000a6c98-bb9b-11e8-b2b9-ac1f6b6435d0',
    '001838f8-bbca-11e8-b2bc-ac1f6b6435d0',
    '000c99ba-bba4-11e8-b2b9-ac1f6b6435d0',
    'a34d8680-bb99-11e8-b2b9-ac1f6b6435d0',
    '000a9596-bbc4-11e8-b2bc-ac1f6b6435d0']

# Cell

def read_img(
    dir_data, image_id, color,
    train_or_test='train', image_size=None, suffix='.png'):

    filename = (f'{dir_data}/{train_or_test}/'
                f'{image_id}_{color}{suffix}')
    assert os.path.exists(filename), f'not found {filename}'
    img = cv2.imread(filename, cv2.IMREAD_UNCHANGED)
    if image_size is not None:
        img = cv2.resize(img, (image_size, image_size))
    if img.max() > 255:
        img_max = img.max()
        img = (img/255).astype('uint8')
    return img

def load_RGBY_image(
    dir_data, image_id, rgb_only=False,
    train_or_test='train', image_size=None, suffix='.png'):

    red, green, blue = [
        read_img(
            dir_data, image_id, color,
            train_or_test, image_size, suffix)
        for color in ('red', 'green', 'blue')]

    channels = [red, green, blue]

    if not rgb_only:
        yellow = read_img(
            dir_data, image_id, "yellow",
            train_or_test, image_size, suffix)
        channels.append(yellow)

    stacked_images = np.transpose(np.array(channels), (1,2,0))
    return stacked_images

# Cell
import hpacellseg.cellsegmentator as cellsegmentator
from hpacellseg.utils import label_cell, label_nuclei
from tqdm import tqdm

class CellSegmentator(cellsegmentator.CellSegmentator):
    def __init__(self, nuc_model, cell_model, *args, **kwargs):
        nuc_model = str(nuc_model)
        cell_model = str(cell_model)
        super().__init__(nuc_model, cell_model, *args, **kwargs)

    def __call__(self, red, yellow, blue):
        '''
        `red`: list
          Red images' file paths.
        `yellow`: list
          Yellow images' file paths.
        `blue`: list
          Blue images' file paths.
        '''
        assert len(red) == len(yellow) == len(blue)

        if isinstance(red[0], Path):
            red, yellow, blue = (
                [str(n) for n in fns]
                for fns in [red, yellow, blue])

        print('Predicting nuclei and cells...', end='')
        segs_nucl = self.pred_nuclei(blue)
        segs_cell = self.pred_cells([red, yellow, blue])
        print(' done.')

        print('Labelling cells...', end='')
        masks = []
        for seg_nucl, seg_cell in zip(segs_nucl, segs_cell):
            mask_nucl, mask_cell = label_cell(seg_nucl, seg_cell)
            masks.append((mask_nucl, mask_cell))
        print(' done.')

        return masks


def get_cellmask(img, segmentator):
    img_r, img_y, img_b = img[...,0], img[...,3], img[...,2]

    masks = segmentator(red=[img_r], yellow=[img_y], blue=[img_b])

    _, mask = masks[0]
    return mask